{"version":3,"file":"PMREMGenerator.js","sources":["../../../../../node_modules/three/examples/jsm/pmrem/PMREMGenerator.js"],"sourcesContent":["/**\n * @author Prashant Sharma / spidersharma03\n * @author Ben Houston / bhouston, https://clara.io\n *\n * To avoid cube map seams, I create an extra pixel around each face. This way when the cube map is\n * sampled by an application later(with a little care by sampling the centre of the texel), the extra 1 border\n *\tof pixels makes sure that there is no seams artifacts present. This works perfectly for cubeUV format as\n *\twell where the 6 faces can be arranged in any manner whatsoever.\n * Code in the beginning of fragment shader's main function does this job for a given resolution.\n *\tRun Scene_PMREM_Test.html in the examples directory to see the sampling from the cube lods generated\n *\tby this class.\n */\n\nimport {\n\tDoubleSide,\n\tGammaEncoding,\n\tLinearEncoding,\n\tLinearFilter,\n\tLinearToneMapping,\n\tMesh,\n\tNearestFilter,\n\tNoBlending,\n\tOrthographicCamera,\n\tPlaneBufferGeometry,\n\tScene,\n\tShaderMaterial,\n\tWebGLRenderTargetCube,\n\tsRGBEncoding\n} from \"../../../build/three.module.js\";\n\nvar PMREMGenerator = ( function () {\n\n\tvar shader = getShader();\n\tvar camera = new OrthographicCamera( - 1, 1, 1, - 1, 0.0, 1000 );\n\tvar scene = new Scene();\n\tvar planeMesh = new Mesh( new PlaneBufferGeometry( 2, 2, 0 ), shader );\n\tplaneMesh.material.side = DoubleSide;\n\tscene.add( planeMesh );\n\tscene.add( camera );\n\n\tvar PMREMGenerator = function ( sourceTexture, samplesPerLevel, resolution ) {\n\n\t\tthis.sourceTexture = sourceTexture;\n\t\tthis.resolution = ( resolution !== undefined ) ? resolution : 256; // NODE: 256 is currently hard coded in the glsl code for performance reasons\n\t\tthis.samplesPerLevel = ( samplesPerLevel !== undefined ) ? samplesPerLevel : 32;\n\n\t\tvar monotonicEncoding = ( this.sourceTexture.encoding === LinearEncoding ) ||\n\t\t\t( this.sourceTexture.encoding === GammaEncoding ) || ( this.sourceTexture.encoding === sRGBEncoding );\n\n\t\tthis.sourceTexture.minFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;\n\t\tthis.sourceTexture.magFilter = ( monotonicEncoding ) ? LinearFilter : NearestFilter;\n\t\tthis.sourceTexture.generateMipmaps = this.sourceTexture.generateMipmaps && monotonicEncoding;\n\n\t\tthis.cubeLods = [];\n\n\t\tvar size = this.resolution;\n\t\tvar params = {\n\t\t\tformat: this.sourceTexture.format,\n\t\t\tmagFilter: this.sourceTexture.magFilter,\n\t\t\tminFilter: this.sourceTexture.minFilter,\n\t\t\ttype: this.sourceTexture.type,\n\t\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\n\t\t\tanisotropy: this.sourceTexture.anisotropy,\n\t\t\tencoding: this.sourceTexture.encoding\n\t\t};\n\n\t\t// how many LODs fit in the given CubeUV Texture.\n\t\tthis.numLods = Math.log( size ) / Math.log( 2 ) - 2; // IE11 doesn't support Math.log2\n\n\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\n\n\t\t\tvar renderTarget = new WebGLRenderTargetCube( size, size, params );\n\t\t\trenderTarget.texture.name = \"PMREMGenerator.cube\" + i;\n\t\t\tthis.cubeLods.push( renderTarget );\n\t\t\tsize = Math.max( 16, size / 2 );\n\n\t\t}\n\n\t};\n\n\tPMREMGenerator.prototype = {\n\n\t\tconstructor: PMREMGenerator,\n\n\t\t/*\n\t\t * Prashant Sharma / spidersharma03: More thought and work is needed here.\n\t\t * Right now it's a kind of a hack to use the previously convolved map to convolve the current one.\n\t\t * I tried to use the original map to convolve all the lods, but for many textures(specially the high frequency)\n\t\t * even a high number of samples(1024) dosen't lead to satisfactory results.\n\t\t * By using the previous convolved maps, a lower number of samples are generally sufficient(right now 32, which\n\t\t * gives okay results unless we see the reflection very carefully, or zoom in too much), however the math\n\t\t * goes wrong as the distribution function tries to sample a larger area than what it should be. So I simply scaled\n\t\t * the roughness by 0.9(totally empirical) to try to visually match the original result.\n\t\t * The condition \"if(i <5)\" is also an attemt to make the result match the original result.\n\t\t * This method requires the most amount of thinking I guess. Here is a paper which we could try to implement in future::\n\t\t * https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html\n\t\t */\n\t\tupdate: function ( renderer ) {\n\n\t\t\t// Texture should only be flipped for CubeTexture, not for\n\t\t\t// a Texture created via WebGLRenderTargetCube.\n\t\t\tvar tFlip = ( this.sourceTexture.isCubeTexture ) ? - 1 : 1;\n\n\t\t\tshader.defines[ 'SAMPLES_PER_LEVEL' ] = this.samplesPerLevel;\n\t\t\tshader.uniforms[ 'faceIndex' ].value = 0;\n\t\t\tshader.uniforms[ 'envMap' ].value = this.sourceTexture;\n\t\t\tshader.envMap = this.sourceTexture;\n\t\t\tshader.needsUpdate = true;\n\n\t\t\tvar gammaInput = renderer.gammaInput;\n\t\t\tvar gammaOutput = renderer.gammaOutput;\n\t\t\tvar toneMapping = renderer.toneMapping;\n\t\t\tvar toneMappingExposure = renderer.toneMappingExposure;\n\t\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\trenderer.toneMapping = LinearToneMapping;\n\t\t\trenderer.toneMappingExposure = 1.0;\n\t\t\trenderer.gammaInput = false;\n\t\t\trenderer.gammaOutput = false;\n\n\t\t\tfor ( var i = 0; i < this.numLods; i ++ ) {\n\n\t\t\t\tvar r = i / ( this.numLods - 1 );\n\t\t\t\tshader.uniforms[ 'roughness' ].value = r * 0.9; // see comment above, pragmatic choice\n\t\t\t\t// Only apply the tFlip for the first LOD\n\t\t\t\tshader.uniforms[ 'tFlip' ].value = ( i == 0 ) ? tFlip : 1;\n\t\t\t\tvar size = this.cubeLods[ i ].width;\n\t\t\t\tshader.uniforms[ 'mapSize' ].value = size;\n\t\t\t\tthis.renderToCubeMapTarget( renderer, this.cubeLods[ i ] );\n\n\t\t\t\tif ( i < 5 ) shader.uniforms[ 'envMap' ].value = this.cubeLods[ i ].texture;\n\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\t\t\trenderer.toneMapping = toneMapping;\n\t\t\trenderer.toneMappingExposure = toneMappingExposure;\n\t\t\trenderer.gammaInput = gammaInput;\n\t\t\trenderer.gammaOutput = gammaOutput;\n\n\t\t},\n\n\t\trenderToCubeMapTarget: function ( renderer, renderTarget ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\tthis.renderToCubeMapTargetFace( renderer, renderTarget, i );\n\n\t\t\t}\n\n\t\t},\n\n\t\trenderToCubeMapTargetFace: function ( renderer, renderTarget, faceIndex ) {\n\n\t\t\tshader.uniforms[ 'faceIndex' ].value = faceIndex;\n\t\t\trenderer.setRenderTarget( renderTarget, faceIndex );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( scene, camera );\n\n\t\t},\n\n\t\tdispose: function () {\n\n\t\t\tfor ( var i = 0, l = this.cubeLods.length; i < l; i ++ ) {\n\n\t\t\t\tthis.cubeLods[ i ].dispose();\n\n\t\t\t}\n\n\t\t},\n\n\t};\n\n\tfunction getShader() {\n\n\t\tvar shaderMaterial = new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"SAMPLES_PER_LEVEL\": 20,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"faceIndex\": { value: 0 },\n\t\t\t\t\"roughness\": { value: 0.5 },\n\t\t\t\t\"mapSize\": { value: 0.5 },\n\t\t\t\t\"envMap\": { value: null },\n\t\t\t\t\"tFlip\": { value: - 1 },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"#include <common>\\n\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform int faceIndex;\\n\\\n\t\t\t\tuniform float roughness;\\n\\\n\t\t\t\tuniform samplerCube envMap;\\n\\\n\t\t\t\tuniform float mapSize;\\n\\\n\t\t\t\tuniform float tFlip;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\\n\t\t\t\t\tfloat a = ggxRoughness + 0.0001;\\n\\\n\t\t\t\t\ta *= a;\\n\\\n\t\t\t\t\treturn ( 2.0 / a - 2.0 );\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSamplePhong(vec2 uv, mat3 vecSpace, float specPow) {\\n\\\n\t\t\t\t\tfloat phi = uv.y * 2.0 * PI;\\n\\\n\t\t\t\t\tfloat cosTheta = pow(1.0 - uv.x, 1.0 / (specPow + 1.0));\\n\\\n\t\t\t\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\\n\\\n\t\t\t\t\tvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\\n\\\n\t\t\t\t\treturn vecSpace * sampleDir;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvec3 ImportanceSampleGGX( vec2 uv, mat3 vecSpace, float Roughness )\\n\\\n\t\t\t\t{\\n\\\n\t\t\t\t\tfloat a = Roughness * Roughness;\\n\\\n\t\t\t\t\tfloat Phi = 2.0 * PI * uv.x;\\n\\\n\t\t\t\t\tfloat CosTheta = sqrt( (1.0 - uv.y) / ( 1.0 + (a*a - 1.0) * uv.y ) );\\n\\\n\t\t\t\t\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\\n\\\n\t\t\t\t\treturn vecSpace * vec3(SinTheta * cos( Phi ), SinTheta * sin( Phi ), CosTheta);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tmat3 matrixFromVector(vec3 n) {\\n\\\n\t\t\t\t\tfloat a = 1.0 / (1.0 + n.z);\\n\\\n\t\t\t\t\tfloat b = -n.x * n.y * a;\\n\\\n\t\t\t\t\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\\n\\\n\t\t\t\t\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\\n\\\n\t\t\t\t\treturn mat3(b1, b2, n);\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvec4 testColorMap(float Roughness) {\\n\\\n\t\t\t\t\tvec4 color;\\n\\\n\t\t\t\t\tif(faceIndex == 0)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 1)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 2)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 3)\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,1.0,0.0,1.0);\\n\\\n\t\t\t\t\telse if(faceIndex == 4)\\n\\\n\t\t\t\t\t\tcolor = vec4(0.0,1.0,1.0,1.0);\\n\\\n\t\t\t\t\telse\\n\\\n\t\t\t\t\t\tcolor = vec4(1.0,0.0,1.0,1.0);\\n\\\n\t\t\t\t\tcolor *= ( 1.0 - Roughness );\\n\\\n\t\t\t\t\treturn color;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec3 sampleDirection;\\n\\\n\t\t\t\t\tvec2 uv = vUv*2.0 - 1.0;\\n\\\n\t\t\t\t\tfloat offset = -1.0/mapSize;\\n\\\n\t\t\t\t\tconst float a = -1.0;\\n\\\n\t\t\t\t\tconst float b = 1.0;\\n\\\n\t\t\t\t\tfloat c = -1.0 + offset;\\n\\\n\t\t\t\t\tfloat d = 1.0 - offset;\\n\\\n\t\t\t\t\tfloat bminusa = b - a;\\n\\\n\t\t\t\t\tuv.x = (uv.x - a)/bminusa * d - (uv.x - b)/bminusa * c;\\n\\\n\t\t\t\t\tuv.y = (uv.y - a)/bminusa * d - (uv.y - b)/bminusa * c;\\n\\\n\t\t\t\t\tif (faceIndex==0) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(1.0, -uv.y, -uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==1) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-1.0, -uv.y, uv.x);\\n\\\n\t\t\t\t\t} else if (faceIndex==2) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, 1.0, uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==3) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -1.0, -uv.y);\\n\\\n\t\t\t\t\t} else if (faceIndex==4) {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(uv.x, -uv.y, 1.0);\\n\\\n\t\t\t\t\t} else {\\n\\\n\t\t\t\t\t\tsampleDirection = vec3(-uv.x, -uv.y, -1.0);\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\tvec3 correctedDirection = vec3( tFlip * sampleDirection.x, sampleDirection.yz );\\n\\\n\t\t\t\t\tmat3 vecSpace = matrixFromVector( normalize( correctedDirection ) );\\n\\\n\t\t\t\t\tvec3 rgbColor = vec3(0.0);\\n\\\n\t\t\t\t\tconst int NumSamples = SAMPLES_PER_LEVEL;\\n\\\n\t\t\t\t\tvec3 vect;\\n\\\n\t\t\t\t\tfloat weight = 0.0;\\n\\\n\t\t\t\t\tfor( int i = 0; i < NumSamples; i ++ ) {\\n\\\n\t\t\t\t\t\tfloat sini = sin(float(i));\\n\\\n\t\t\t\t\t\tfloat cosi = cos(float(i));\\n\\\n\t\t\t\t\t\tfloat r = rand(vec2(sini, cosi));\\n\\\n\t\t\t\t\t\tvect = ImportanceSampleGGX(vec2(float(i) / float(NumSamples), r), vecSpace, roughness);\\n\\\n\t\t\t\t\t\tfloat dotProd = dot(vect, normalize(sampleDirection));\\n\\\n\t\t\t\t\t\tweight += dotProd;\\n\\\n\t\t\t\t\t\tvec3 color = envMapTexelToLinear(textureCube(envMap, vect)).rgb;\\n\\\n\t\t\t\t\t\trgbColor.rgb += color;\\n\\\n\t\t\t\t\t}\\n\\\n\t\t\t\t\trgbColor /= float(NumSamples);\\n\\\n\t\t\t\t\t//rgbColor = testColorMap( roughness ).rgb;\\n\\\n\t\t\t\t\tgl_FragColor = linearToOutputTexel( vec4( rgbColor, 1.0 ) );\\n\\\n\t\t\t\t}\",\n\n\t\t\tblending: NoBlending\n\n\t\t} );\n\n\t\tshaderMaterial.type = 'PMREMGenerator';\n\n\t\treturn shaderMaterial;\n\n\t}\n\n\treturn PMREMGenerator;\n\n} )();\n\nexport { PMREMGenerator };\n"],"names":[],"mappings":"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"}